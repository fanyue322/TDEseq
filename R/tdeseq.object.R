#####################################################################
# Package: TDEseq
# Version: 0.0.1
# Modified: 2023-12-9 10:05:02
# Title :  Detecting temporal gene expression changes in the developmental stages of single-cell RNA sequencing studies 
# Authors: Yue Fan and Shiquan Sun
# Contacts: sqsunsph@xjtu.edu.cn; xafanyue@xjtu.edu.cn
#          Xi'an Jiatong University, Department of Biostatistics
######################################################################
#' Each TDEseq object has a number of slots which store information. Key slots to access
#' are listed below.
#'
#' @slot assays A list of assays for this project
#' @slot active.assay Name of the active, or default, assay; settable using
#' \code{\link{DefaultAssay}}
#' @slot project.name Name of the project
#' @slot misc A list of miscellaneous information
#' @slot version Version of TDEseq this object was built under
#' @slot species Could be human, mouse, or rhe, etc
#' @slot commands A list of logged commands run on this \code{TDEseq} object
#' @slot tools A list of miscellaneous data generated by other tools, should be
#' filled by developers only using \code{\link{Tool}<-}
#'
#' @name TDEseq-class
#' @rdname TDEseq-class
#' @exportClass TDEseq
#'
TDEseq <- setClass(Class = 'TDEseq',
	slots = c(assays = 'list',
	          active.assay = 'character',
	          project.name = 'character',
	          res.path = "character",
	          species = "character",
	          misc = 'list',
	          num.core = 'numeric',
	          commands = 'list',
	          version = 'character',
	          tools = 'list'))

#' The Assay Class
#'
#' The Assay object is the basic unit of Seurat; each Assay stores raw,
#' normalized, and scaled data as well as cluster information, variable
#' features, and any other assay-specific metadata. Assays should contain single
#' cell expression data such as RNA-seq, protein, or imputed expression data.
#'
#' @slot counts Unnormalized data such as raw counts or TPMs
#' @slot data Normalized expression data
#' @slot scale.data Scaled expression data
#' @slot key Key for the Assay
#' @slot assay.orig Original assay that this assay is based off of. Used to
#' track assay provenance
#' @slot svg Vector of features exhibiting high variance across
#' single cells
#' @slot meta.features Feature-level metadata
#' @name Assay-class
#' @rdname Assay-class
#' @exportClass Assay
#'
#' @concept assay
#'
Assay <- setClass(
	Class = "Assay",
		slots = c(
		counts = "ANY",
		data = "ANY",
		scale.data = "ANY",
		total.counts = "ANY",
		key = 'character',
		ident = "factor", ## cell type or clustering information
		meta.features = "data.frame",
		meta.data = "data.frame",
		dr = "list",
		tde = "data.frame",
		svg = "ANY",
		de.truth = "ANY",
		misc = "ANY"))


###########################################
#' Create an Assay object. Create an Assay object from a feature (e.g. gene) expression matrix. The
#' expected format of the input matrix is features x cells.
#'
#' @param counts Unnormalized data such as raw counts or TPMs
#' @param data Prenormalized data; if provided, do not pass \code{counts}
#' @param min.cells Include features detected in at least this many cells. Will
#' subset the counts matrix as well. To reintroduce excluded features, create a
#' new object with a lower cutoff.
#' @param min.features Include cells where at least this many features are
#' detected.
#' @param ... Arguments passed to \code{\link{as.sparse}}
#'
#' @return A \code{\link{Assay}} object
#'
#' @importFrom methods as
#' @importFrom Matrix colSums rowSums
#'
#' @export
CreateAssayObject <- function(counts,
		data = NULL,
		min.cells = 0,
		min.features = 0,
		pct.cells = 0.005,
		min.umi = 10,
		num.core = 1,...) {
	
	## inputs checking
	if (missing(x = counts) && is.null(x = data)) {
		stop("Must provide either 'counts' or 'data'")
	} else if (!missing(x = counts) && !is.null(x = data)) {
		# stop("Either 'counts' or 'data' must be missing; both cannot be provided")
	  if (!inherits(x = counts, what = 'dgCMatrix')) {
	    #counts <- as.sparse(x = counts, ...)
	    counts <- as(counts,"sparseMatrix")
	  }## end fi
	  
	  if (!identical(dim(counts), dim(data))) {
	    stop("The dimension of matrices 'counts' and 'data' must be matched!")
	  }## end fi
	  
	  
	  ##
	  if(any(grepl(pattern = '|', x = rownames(x = counts), fixed = TRUE)) || any(grepl(pattern = '|', x = rownames(x = data), fixed = TRUE))) {
	    warning(
	      "Feature names cannot have pipe characters ('|'), replacing with dashes ('-')",
	      call. = FALSE,
	      immediate. = TRUE)
	    
	    rownames(x = counts) <- gsub(
	      pattern = '|',
	      replacement = '-',
	      x = rownames(x = counts),
	      fixed = TRUE)
	    
	    rownames(x = data) <- gsub(
	      pattern = '|',
	      replacement = '-',
	      x = rownames(x = data),
	      fixed = TRUE)
	  }## end fi
	  
	} else if (!missing(x = counts)) {
		# check that dimnames of input counts are unique
		if (anyDuplicated(x = rownames(x = counts))) {
			warning(
				"Non-unique features (rownames) present in the input matrix, making unique",
				call. = FALSE,
				immediate. = TRUE)
			rownames(x = counts) <- make.unique(names = rownames(x = counts))
		}## end fi
		
		if (anyDuplicated(x = colnames(x = counts))) {
			warning(
				"Non-unique cell names (colnames) present in the input matrix, making unique",
				call. = FALSE,
				immediate. = TRUE)
			colnames(x = counts) <- make.unique(names = colnames(x = counts))
		}## end fi
	
		if (is.null(x = colnames(x = counts))) {
			stop("No cell names (colnames) names present in the input matrix")
		}## end fi
		
		if (any(rownames(x = counts) == '')) {
			stop("Feature names of counts matrix cannot be empty", call. = FALSE)
		}## end fi
		
		if (nrow(x = counts) > 0 && is.null(x = rownames(x = counts))) {
			stop("No feature names (rownames) names present in the input matrix")
		}## end fi

		if (!inherits(x = counts, what = 'dgCMatrix')) {
		  #counts <- as.sparse(x = counts, ...)
		  counts <- as(counts,"sparseMatrix")
		}## end fi

		## filtering out lowly expressed genes by percentage = 0.005
		if (pct.cells > 0){
			num.cells <- Matrix::rowSums(counts > 0)
			counts	<- counts[which(num.cells >= floor(pct.cells*ncol(counts))),]
		}## end fi
	
		## filter genes on the number of cells expressing
		if (min.cells > 0) {
			num.cells <- Matrix::rowSums(x = counts > 0)
			counts <- counts[which(x = num.cells >= min.cells), ]
		}## end fi
		
		## Filter based on min.features
		if (min.features > 0) {
			nfeatures <- Matrix::colSums(x = counts > 0)
			counts <- counts[, which(x = nfeatures >= min.features)]
		}## end fi
		
		if (min.umi > 0) {
			total.umi <- Matrix::colSums(x = counts)
			counts <- counts[, which(x = total.umi > min.umi)]
		}## end fi
	  
	  data <- new(Class = 'matrix')
		#data <- counts
		# lib_size <- Matrix::colSums(counts)
		# data <- log(sweep(counts, 2, lib_size, "/")*1e4 + 1.0)
	} else if (!is.null(x = data)) {
		## check that dimnames of input data are unique
		if (anyDuplicated(x = rownames(x = data))) {
		  warning(
			"Non-unique features (rownames) present in the input matrix, making unique",
			call. = FALSE,
			immediate. = TRUE
		  )
		  rownames(x = data) <- make.unique(names = rownames(x = data))
		}
		if (anyDuplicated(x = colnames(x = data))) {
		  warning(
			"Non-unique cell names (colnames) present in the input matrix, making unique",
			call. = FALSE,
			immediate. = TRUE
		  )
		  colnames(x = data) <- make.unique(names = colnames(x = data))
		}
		if (is.null(x = colnames(x = data))) {
		  stop("No cell names (colnames) names present in the input matrix")
		}
		if (any(rownames(x = data) == '')) {
		  stop("Feature names of data matrix cannot be empty", call. = FALSE)
		}
		if (nrow(x = data) > 0 && is.null(x = rownames(x = data))) {
		  stop("No feature names (rownames) names present in the input matrix")
		}
		if (min.cells != 0 | min.features != 0) {
		  warning(
			"No filtering performed if passing to data rather than counts",
			call. = FALSE,
			immediate. = TRUE
		  )
		}
		counts <- new(Class = 'matrix')
	}## end fi

	## Ensure row- and column-names are vectors, not arrays
	if(!is.vector(x = rownames(x = counts))){rownames(x = counts) <- as.vector(x = rownames(x = counts))}
	if(!is.vector(x = colnames(x = counts))){colnames(x = counts) <- as.vector(x = colnames(x = counts))}
	if(!is.vector(x = rownames(x = data))){rownames(x = data) <- as.vector(x = rownames(x = data))}
	if(!is.vector(x = colnames(x = data))){colnames(x = data) <- as.vector(x = colnames(x = data))}
	if(any(grepl(pattern = '_', x = rownames(x = counts))) || any(grepl(pattern = '_', x = rownames(x = data)))) {
		## replace underscores _ with dashes -
		suppressWarnings(warning("Feature names cannot have underscores ('_'), replacing with dashes ('-')",call. = FALSE,immediate. = TRUE))
		## commands for row names and colnum names
		rownames(x = counts) <- gsub(pattern = '_',
		  replacement = '-',
		  x = rownames(x = counts)
		)
		rownames(x = data) <- gsub(pattern = '_',
		  replacement = '-',
		  x = rownames(x = data)
		)
	}## end fi
  
	##
	if(any(grepl(pattern = '|', x = rownames(x = counts), fixed = TRUE)) || any(grepl(pattern = '|', x = rownames(x = data), fixed = TRUE))) {
		warning(
		  "Feature names cannot have pipe characters ('|'), replacing with dashes ('-')",
		  call. = FALSE,
		  immediate. = TRUE)
		  
		rownames(x = counts) <- gsub(
		  pattern = '|',
		  replacement = '-',
		  x = rownames(x = counts),
		  fixed = TRUE)
		
		rownames(x = data) <- gsub(
		  pattern = '|',
		  replacement = '-',
		  x = rownames(x = data),
		  fixed = TRUE)
	}## end fi
	
	## Initialize meta.features
	init.meta.features <- data.frame(row.names = rownames(x = data))
	assay <- new(Class = 'Assay', counts = counts, data = data,
		scale.data = new(Class = 'matrix'),
		meta.features = init.meta.features,
		misc = list())
	return(assay)
}## end func

#'
#' @param row.names When \code{counts} is a \code{data.frame} or
#' \code{data.frame}-derived object: an optional vector of feature names to be
#' used
#'
#' @rdname CreateTDEseqObject
#' @method CreateTDEseqObject default
#' @export
#'
CreateTDEseqObject.default <- function(counts,
                                       data = NULL,
                                       project = 'TDEseq',
                                       assay = 'RNA',
                                       meta.data = NULL,
                                       species = "hsa",
                                       names.field = 1,
                                       names.delim = '_',
                                       min.cells = 0,
                                       pct.cells = 0.005,
                                       min.features = 0,
                                       min.umi = 10,
                                       num.core = 1,
                                       row.names = NULL,
                                       version = "0.0.1", ...) {
	
	## set idents
	idents <- factor(x = unlist(x = lapply(X = colnames(x = counts), 
	                                       FUN = ExtractField, field = names.field, delim = names.delim)))
	
	## if there are more than 100 idents, set all idents to ... name
	ident.levels <- length(x = unique(x = idents))
	if(ident.levels > 100 || ident.levels == 0 || ident.levels == length(x = idents)){
		idents <- rep.int(x = factor(x = project), times = ncol(x = counts))
	}## end fi
	names(x = idents) <- colnames(x = counts)
	
	## change counts names for integrative analysis of multiple 
	# colnames(counts) <- paste0(colnames(counts),".", assay)
	
	## create assay data
	assay.data <- CreateAssayObject(counts = counts, 
	                                data = data,
                									min.cells = min.cells,
                									pct.cells = pct.cells,
                									min.umi = min.umi,
                									min.features = min.features, 
                									row.names = row.names, 
                									num.core = num.core)
	assay.data@ident <- idents
	
	## information proprecess
	object <- CreateTDEseqObject(counts = assay.data,
	                               project = project,
	                               assay = assay,
	                               names.field = names.field,
	                               names.delim = names.delim,
	                               num.core = num.core,...)
	
	## add meta.data
	if(!is.null(meta.data)){object <- AddMetaData(object, meta.data = meta.data)}
	
	## species for this study
	object@species <- species
	object@version <- as.character(version)
	object@num.core <- num.core
	return(object)
}## end funcs



#'
#' @rdname CreateTDEseqObject
#' @method CreateTDEseqObject Assay
#' @export
#'
CreateTDEseqObject.Assay <- function(counts,
                                      project = 'TDEseq',
                                      assay = 'RNA',
                                      names.field = 1,
                                      names.delim = '_',
                                      num.core = 1,
                                      meta.data = NULL, ...) {
	
	assay.list <- list(counts)
	names(x = assay.list) <- assay
	
	## create new TDEseq object
	object <- new(Class = 'TDEseq',
		assays = assay.list,
		active.assay = assay,
		project.name = project)

	### Calculate library size and number of expressed genes or cells
	metrics <- CalQCMetrics(object = object)

	if (!is.null(x = metrics)) {
		colnames(x = metrics$cell_level) <- paste(colnames(x = metrics$cell_level), assay, sep = '_')
		object <- SetAssayData(object, slot = "meta.data", new.data = as.data.frame(metrics$cell_level))
		
		colnames(x = metrics$feature_level) <- paste(colnames(x = metrics$feature_level), assay, sep = '_')
		object <- SetAssayData(object, slot = "meta.features", new.data = as.data.frame(metrics$feature_level))
	}## end fi
	
	## Add metadata
	return(object)
}## end funcs



#' Create a TDEseq object based on an Seurat object
#' @rdname CreateTDEseqObject
#' @method CreateTDEseqObject Seurat
#' @export
#'
CreateTDEseqObject.Seurat <- function(counts,
                                          project = "TDEseq",
                                          assay = "RNA",
                                          min.cells = 0,
                                          pct.cells = 0.005,
                                          min.umi = 10,
                                          num.core = 1,
                                          min.features = 0,
                                          row.names = NULL,  ...) {
  ## package check
  if(!require('Seurat')) {
    stop("Please install Seurat from CRAN",
         "\nhttps://github.com/satijalab/seurat",
         call. = FALSE)
  }## end fi
  ## create the list for assays
  assay.list <- list()
  assay.data <- CreateObject.Each(counts = Seurat::GetAssayData(counts, slot="counts"),
                                  data = Seurat::GetAssayData(counts, slot="data"),
                                  meta.data = slot(counts, name="meta.data"),
                                  min.cells = min.cells,
                                  pct.cells = pct.cells,
                                  min.umi = min.umi,
                                  num.core = num.core,
                                  min.features = min.features,
                                  row.names = row.names)
  ## add a new assay
  assay.data <- SetAssayData(assay.data, slot="ident", new.data=as.factor(colnames(counts))) 
  assay.list[[1]] <- assay.data
  names(assay.list) <- assay
    

  
  
  ## create new TDEseq object
  object <- new(Class = 'TDEseq',
                assays = assay.list,
                active.assay = 'RNA',
                num.core = num.core,
                project.name = project)
  ## return the project
  return(object)
}## end funcs



#' Create a TDEseq object based on an SingleCellExperimentobject
#' @rdname CreateTDEseqObject
#' @method CreateTDEseqObject SingleCellExperiment
#' @export
#'
CreateTDEseqObject.SingleCellExperiment <- function(counts,
                                      project = "TDEseq",
                                      assay = "RNA",
                                      slot.use = "counts",
                                      min.cells = 0,
                                      pct.cells = 0.005,
                                      min.umi = 10,
                                      num.core = 1,
                                      min.features = 0,
                                      row.names = NULL,  ...) {
  ## package check
  if(!require('SingleCellExperiment')) {
    stop("Please install SingleCellExperiment from Bioconductor.",
      "\nhttps://bioconductor.org/packages/SingleCellExperiment/",
      call. = FALSE)
  }## end fi
  
  ## create the list for assays
  assay.list <- list()
  assay.data <- CreateObject.Each(counts = SummarizedExperiment::assay(x = counts, i = "counts"),
                                  data = NULL, 
                                  meta.data = as.data.frame(SummarizedExperiment::colData(x = counts)),
                                  min.cells = min.cells,
                                  pct.cells = pct.cells,
                                  min.umi = min.umi,
                                  num.core = num.core,
                                  min.features = min.features,
                                  row.names = row.names)
  ## add a new assay
  assay.data <- SetAssayData(assay.data, slot="ident", new.data=as.factor(colnames(counts))) 
  assay.list[[1]] <- assay.data
  names(assay.list) <- assay
  
  
  ## create new TDEseq object
  object <- new(Class = 'TDEseq',
                assays = assay.list,
                active.assay = 'RNA',
                num.core = num.core,
                project.name = project)
  ## return the project
  return(object)
}## end


#' @rdname Version
#' @method Version TDEseq
#' @export
#'
Version.TDEseq <- function(object, ...) {
  return(slot(object = object, name = 'version'))
}## end func


##################################################
#' Get Version Information
#' @param object An object
#' @param ... Arguments passed to other methods
#'
#' @rdname Version
#' @export Version
#'
#' @concept data-access
#'
#' @examples
#' Version(object)
#'
Version <- function(object, ...) {
  UseMethod(generic = "Version", object = object)
}## end func


#' Create a \code{TDEseq} object from raw data
#'
#' @inheritParams CreateAssayObject
#' @param counts Either a \code{\link[base]{matrix}}-like object with
#' unnormalized data with cells as columns and features as rows or an
#' \code{\link{Assay}}-derived object
#' @param project \link{Project} name for the \code{TDEseq} object
#' @param assay Name of the initial assay
#' @param names.field For the initial identity class for each cell, choose this
#' field from the cell's name. E.g. If your cells are named as
#' BARCODE_CLUSTER_CELLTYPE in the input matrix, set \code{names.field} to 3 to
#' set the initial identities to CELLTYPE.
#' @param names.delim For the initial identity class for each cell, choose this
#' delimiter from the cell's column name. E.g. If your cells are named as
#' BARCODE-CLUSTER-CELLTYPE, set this to \dQuote{-} to separate the cell name
#' into its component parts for picking the relevant field.
#' @param ... Arguments passed to other methods
#'
#' @return A \code{\link{TDEseq}} object
#'
#' @rdname CreateTDEseqObject
#' @export
#'
#'
CreateTDEseqObject <- function(counts,
	project = 'TDEseq',
	assay = 'RNA',
	names.field = 1,
	names.delim = '_', ...) {
		UseMethod(generic = 'CreateTDEseqObject', object = counts)
}## end funcs

#' @describeIn TDEseq-methods Calculate \code{\link[base]{colMeans}} on a
#' \code{TDEseq} object
#'
#' @param slot Name of assay expression matrix to calculate column/row
#' means/sums on
#' @inheritParams Matrix::colMeans
#'
#' @importFrom Matrix colMeans
#'
#' @export
#'
#' @examples
#' head(colMeans(object))
#'
setMethod(f = 'colMeans',
  signature = c('x' = 'TDEseq'),
  definition = function(x, na.rm = FALSE, dims = 1, ..., slot = 'counts') {
    return(colMeans(x = GetTDEseqAssayData(object = x, slot = slot), na.rm = na.rm, dims = dims,
      ...))
  })


#' @describeIn TDEseq-methods Calculate \code{\link[base]{colSums}} on a
#' \code{TDEseq} object
#'
#' @importFrom Matrix colSums
#'
#' @export
#'
#' @examples
#' head(colSums(object))
#'
setMethod(f = 'colSums',
  signature = c('x' = 'TDEseq'),
  definition = function(x, na.rm = FALSE, dims = 1, ..., slot = 'counts') {
    return(Matrix::colSums(x = GetTDEseqAssayData(object = x, slot = slot), na.rm = na.rm, dims = dims,
      ...))
  })

#' @describeIn TDEseq-methods Calculate \code{\link[base]{rowMeans}} on a
#' \code{rowMeans} object
#'
#' @importFrom Matrix colSums
#'
#' @export
#'
#' @examples
#' head(rowMeans(object))
#'
setMethod(f = 'rowMeans',
  signature = c('x' = 'TDEseq'),
  definition = function(x, na.rm = FALSE, dims = 1, ..., slot = 'counts') {
    return(Matrix::rowMeans(x = GetTDEseqAssayData(object = x, slot = slot),na.rm = na.rm,dims = dims,
      ...))
  })



#' @describeIn TDEseq-methods Calculate \code{\link[base]{rowSums}} on a
#' \code{TDEseq} object
#'
#' @importFrom Matrix rowSums
#'
#' @export
#'
#' @examples
#' head(rowSums(object))
#'
setMethod(f = 'rowSums',
  signature = c('x' = 'TDEseq'),
  definition = function(x, na.rm = FALSE, dims = 1, ..., slot = 'counts') {
    return(Matrix::rowSums(x = GetTDEseqAssayData(object = x, slot = slot),na.rm = na.rm,dims = dims,
      ...))
  })

#' @describeIn TDEseq-methods Calculate \code{\link[base]{names}} on a
#' \code{TDEseq} object
#' 
#' @export
#'
#' @examples
#' head(names(object))
#'
setMethod(f = 'names',
  signature = c('x' = 'TDEseq'),
  definition = function(x) {
    return(names(slot(object = x, name = "assays")))
  })

#' @describeIn TDEseq-methods Overview of a \code{TDEseq} object
#'
#' @return \code{show}: Prints summary to \code{\link[base]{stdout}} and
#' invisibly returns \code{NULL}
#'
#' @importFrom methods show
#'
#' @export
#'
setMethod(f = "show",
  signature = "TDEseq",
  definition = function(object) {
	assays <- names(slot(object = object, name = 'assays'))
    nfeatures <- sum(vapply(X = assays,
      FUN = function(x) {
        return(nrow(x = object[[x]]))
      }, FUN.VALUE = integer(length = 1L)  ))
    
    num.assays <- length(x = assays)
    
    cat("## An object of class", class(x = object), 'with', num.assays,
      ifelse(test = num.assays == 1, yes = 'assay', no = 'assays'), "\n")
    for(iassay in 1:num.assays){
      cat("### Assay ", iassay, ' (',assays[iassay],') : ', 
          dim(x = object[[assays[iassay]]])[1],' features; ', 
          dim(x = object[[assays[iassay]]])[2] , ' samples. \n')
    }## end for
    cat("## Active assay is: ",  DefaultAssay(object = object), "\n")
    cat("## Package version is: ",  Version(object) ,"\n")
    cat('\n')
  })


#' @describeIn Assay-methods Overview of a \code{Assay} object
#'
#' @return \code{show}: Prints summary to \code{\link[base]{stdout}} and
#' invisibly returns \code{NULL}
#'
#' @importFrom methods show
#'
#' @export
#'
setMethod(f = "show",
          signature = "Assay",
          definition = function(object) {
            cat("## An object of class: ", class(x = object), "\n")
            cat("### Assay dimension is: ",
                  dim(x = slot(object = object, name = "counts"))[1],' features; ', 
                  dim(x = slot(object = object, name = "counts"))[2] , ' samples. \n')
            cat('\n')
          })

#' Check if a matrix is empty
#'
#' Takes a matrix and asks if it's empty (either 0x0 or 1x1 with a value of NA)
#'
#' @param x A matrix
#'
#' @return Whether or not \code{x} is empty
#'
#' @export
#'
#' @concept utils
#'
#' @examples
#' IsMatrixEmpty(new("matrix"))
#' IsMatrixEmpty(matrix())
#' IsMatrixEmpty(matrix(1:3))
#'
IsMatrixEmpty <- function(x) {
	matrix.dims <- dim(x = x)
	matrix.na <- all(matrix.dims == 1) && all(is.na(x = x))
	return(all(matrix.dims == 0) || matrix.na)
}## end func



#' Extract delimiter information from a string.
#'
#' Parses a string (usually a cell name) and extracts fields based
#'  on a delimiter
#'
#' @param string String to parse.
#' @param field Integer(s) indicating which field(s) to extract. Can be a
#' vector multiple numbers.
#' @param delim Delimiter to use, set to underscore by default.
#'
#' @return A new string, that parses out the requested fields, and
#' (if multiple), rejoins them with the same delimiter
#'
ExtractField <- function(string, field = 1, delim = "_") {
  fields <- as.numeric(x = unlist(x = strsplit(x = as.character(x = field),
    split = "," )))
  if (length(x = fields) == 1) {
    return(strsplit(x = string, split = delim)[[1]][field])
  }
  return(paste(strsplit(x = string, split = delim)[[1]][fields], collapse = delim ))
}## end func


#' @rdname AddMetaData
#' @export
#' @method AddMetaData Assay
#'
AddMetaData.Assay <- function(object, meta.data, col.name = NULL) {
  
  if (is.null(x = col.name) && is.atomic(x = meta.data)) {
    stop("'col.name' must be provided for atomic metadata types (eg. vectors)")
  }## end fi
  
  ## to be data frame
  if (inherits(x = meta.data, what = c('matrix', 'Matrix'))) {
    meta.data <- as.data.frame(x = meta.data)
  }## end fi
  
  col.name <- col.name %||% names(x = meta.data) %||% colnames(x = meta.data)
  if (is.null(x = col.name)) {
    stop("No meta.data name provided and could not infer it from meta.data object")
  }## end fi
  
  ## original meta data
  old_metadata <- slot(object, name="meta.data")
  ##old_metadata[[col.name]] <- metadata
  
  ## update meta data
  if(is_empty(old_metadata)){
    object@meta.data <- meta.data
  }else if(identical(rownames(old_metadata), rownames(meta.data))){
    object@meta.data <- data.frame(old_metadata, col.name=meta.data)
  }else{
    stop("AddMetaData:: The rownames of meta.data is not match the original rownames of meta.data!")
  }## end fi
  
  
  return(object)
}## end funcs


#' Add Object Metadata
#'
#' Internal \code{\link{AddMetaData}} definition
#'
#' @param object An object
#' @param metadata A data.frame to add, the rownames of metadata must be the same as colnames of
#' @param col.name A name for meta data if not a named list or data.frame
#'
#' @return object with meta.data added
#'
#' @keywords internal
#'
#' @noRd
#'
AddMetaData.TDEseq <- function(object, meta.data, assay = NULL, col.name = NULL) {
  
  ## select which data to use
  assay <- assay %||% DefaultAssay(object = object)
  assay.data <- GetAssay(object = object, assay = assay)
  
  if (is.null(x = col.name) && is.atomic(x = meta.data)) {
    stop("'col.name' must be provided for atomic meta.data types (eg. vectors)")
  }## end fi
  
  ## to be data frame
  if (inherits(x = meta.data, what = c('matrix', 'Matrix'))) {
    meta.data <- as.data.frame(x = meta.data)
  }## end fi
  
  col.name <- col.name %||% names(x = meta.data) %||% colnames(x = meta.data)
  if (is.null(x = col.name)) {
    stop("No meta.data name provided and could not infer it from meta.data object")
  }## end fi
  
  ## original meta data
  colnames(meta.data) <- col.name
  old_metadata <- slot(assay.data, name="meta.data")
  library(dplyr)
  old_metadata <- merge(old_metadata, meta.data, by="row.names") %>% tibble::column_to_rownames(var="Row.names")
  # old_metadata[[col.name]] <- meta.data
  
  ## update meta data
  slot(assay.data, name="meta.data") <- old_metadata
  object@assays[[assay]] <- assay.data
  
  return(object)
}## end funcs


#' Add metadata to the exist Assay object
#'
#' @param x An object
#' @param ... Arguments passed to other methods
#'
#' @export AddMetaData
#'
#' @concept utils
#'
AddMetaData <- function(object, ...) {
  UseMethod(generic = 'AddMetaData', object = object)
}## end func

#' @rdname CalQCMetrics
#' @export
#' @method CalQCMetrics Assay
#'
CalQCMetrics.Assay <- function(object) {
	if (IsMatrixEmpty(x = GetTDEseqAssayData(object = object, slot = "counts"))) {
		return(NULL)
	}## end fi
	return(list(cell_level = data.frame(lib.size = Matrix::colSums(GetTDEseqAssayData(object = object, slot = "counts")),
		  expr.feature = Matrix::colSums(GetTDEseqAssayData(object = object, slot = "counts") > 0), 
		  pct.dropout = 100*(1 - Matrix::colSums(GetTDEseqAssayData(object = object, slot = "counts") > 0)/nrow(object))), 
		feature_level = data.frame(expr.counts = Matrix::rowSums(GetTDEseqAssayData(object = object, slot = "counts")), 
		  expr.cell = Matrix::rowSums(GetTDEseqAssayData(object = object, slot = "counts") > 0),
		  pct.dropout = 100*(1 - Matrix::rowSums(GetTDEseqAssayData(object = object, slot = "counts") > 0)/ncol(object)),
		  mean = Matrix::rowMeans(GetTDEseqAssayData(object = object, slot = "counts")),
		  var = matrixStats::rowVars(as.matrix(GetTDEseqAssayData(object = object, slot = "counts"))) )))
}## end func

#' @rdname CalQCMetrics
#' @export
#' @method CalQCMetrics TDEseq
#'
CalQCMetrics.TDEseq <- function(object, assay = NULL) {
	## extract the active assay, RNA or ATAC or Spatial
	assay <- assay %||% DefaultAssay(object = object)
	## Assay object
	assay.data <- GetAssay(object = object, assay = assay)
	meta.data <- CalQCMetrics(assay.data)

	return(meta.data)
}## end func


#' Calculate meta information
#' @param object An object
#' @param ... Arguments passed to other methods
#'
CalQCMetrics <- function(object, ...) {
  UseMethod(generic = "CalQCMetrics", object = object)
}## end func


#' @rdname DefaultAssay
#' @export
#' @method DefaultAssay TDEseq
#'
DefaultAssay.TDEseq <- function(object, ...) {
	return(slot(object = object, name = 'active.assay'))
}## end func


#' @rdname DefaultAssay
#' @export
#' @method DefaultAssay<- Assay
#'
"DefaultAssay<-.TDEseq" <- function(object, ..., value) {
  
  if (!value %in% names(x = slot(object = object, name = 'assays'))) {
    stop("Cannot find assay: ", value)
  }
	slot(object = object, name = 'active.assay') <- value
	return(object)
}## end func

#' Default Assay 
#'
#'
#' @param object An object
#' @param ... Arguments passed to other methods
#'
DefaultAssay <- function(object, ...) {
	UseMethod(generic = 'DefaultAssay', object = object)
}## end func

#' @param value Name of assay to set as default
#'
#' @return \code{DefaultAssay<-}: An object with the default assay updated
#'
#' @rdname DefaultAssay
#' @export DefaultAssay<-
#'
"DefaultAssay<-" <- function(object, ..., value) {
	UseMethod(generic = 'DefaultAssay<-', object = object)
}## end funcs

#' @rdname AssayData
#' @export
#' @method GetTDEseqAssayData Assay
#'
#' @examples
#' # Get the data directly from an Assay object
#' GetTDEseqAssayData(pbmc_small[["RNA"]], slot = "data")[1:5,1:5]
#'
GetTDEseqAssayData.Assay <- function(object,
  slot = c('data', 
	'scale.data', 
	'counts',
	'meta.data',
	'meta.features',
	'ident',
	'tde',
	'dr',
	'svg',
	'de.truth'), ...) {
	slot <- slot[1]
	slot <- match.arg(arg = slot)
	return(slot(object = object, name = slot))
}## end func



#' @param assay Specific assay to get data from or set data for; defaults to
#' the \link[SCWebObject:DefaultAssay]{default assay}
#'
#' @rdname AssayData
#' @export
#' @method GetTDEseqAssayData TDEseq
#'
#' @order 3
#'
#' @examples
#' # Get assay data from the default assay in a TDEseq object
#' GetTDEseqAssayData(object = pbmc_small, slot = "data")[1:5,1:5]
#'
GetTDEseqAssayData.TDEseq <- function(object, slot = 'data', assay = NULL, ...) {
	assay <- assay %||% DefaultAssay(object = object)
	if (!assay %in% names(object@assays)) {
		stop("'", assay, "' is not an assay", call. = FALSE)
	}## end fi
	return(GetTDEseqAssayData(object = object@assays[[assay]], slot = slot))
}## end funcs

#'
#' @param object An object
#' @param slot Specific assay data to get or set
#' @param ... Arguments passed to other methods
#'
#' @return \code{GetTDEseqAssayData}: returns the specified assay data
#'
#' @name AssayData
#' @rdname AssayData
#' @export GetTDEseqAssayData
#'
GetTDEseqAssayData <- function(object, slot, ...) {
	UseMethod(generic = 'GetTDEseqAssayData', object = object)
}## end func


#' @rdname AssayData
#' @export
#' @method SetAssayData Assay
#'
SetAssayData.Assay <- function(object,
  new.data,
  slot = c('data', 
	'scale.data', 
	'counts',
	'meta.data',
	'meta.features',
	'ident',
	'dr',
	'tde',
	'svg',
	'de.truth'), ...) {
  
	slot <- slot[1]
	slot <- match.arg(arg = slot)
	  if (!IsMatrixEmpty(x = new.data)) {
	    if (any(grepl(pattern = '_', x = rownames(x = new.data)))) {
	      warning(
	        "Feature names cannot have underscores ('_'), replacing with dashes ('-')",
	        call. = FALSE,
	        immediate. = TRUE)
	      
	      rownames(x = new.data) <- gsub(
	        pattern = '_',
	        replacement = '-',
	        x = rownames(x = new.data)
	      )
	    }## end fi
	  }## end fi
	  
	  ## set the results
	  slot(object = object, name = slot) <- new.data
	
	## return results
	return(object)
}## end func


#' @rdname AssayData
#' @export
#' @method SetAssayData TDEseq
#'
#'
SetAssayData.TDEseq <- function(
  object,
  slot = 'data',
  new.data,
  assay = NULL, ...) {
	assay <- assay %||% DefaultAssay(object = object)
	object@assays[[assay]] <- SetAssayData(
		object = object@assays[[assay]],
		slot = slot,
		new.data = new.data, ...)
	## return the object
	return(object)
}## end func

#' @param new.data New assay data to add
#'
#' @return \code{SetAssayData}: \code{object} with the assay data set
#'
#' @rdname AssayData
#' @export SetAssayData
#'
#' @order 2
#'
#'
SetAssayData <- function(object, slot, new.data, ...) {
	UseMethod(generic = 'SetAssayData', object = object)
}## end func

#' @param assay Assay to get
#'
#' @rdname GetAssay
#' @concept objects
#' @export
#' @method GetAssay TDEseq
#'
#' @examples
#' data("pbmc_small")
#' GetAssay(object = pbmc_small, assay = "RNA")
#'
GetAssay.TDEseq <- function(object, assay = NULL, ...) {
	assay <- assay %||% DefaultAssay(object = object)
	object.assays <- names(object@assays)
	if (!assay %in% object.assays) {
		stop(paste0(assay,
		  " is not an assay present in the given object. Available assays are: ",
		  paste(object.assays, collapse = ", ")
		))
	}## end fi
	return(slot(object = object, name = 'assays')[[assay]])
}## end func

#' @param new.data New assay data to add
#'
#' @return \code{GetAssay}: \code{object} with the assay data set
#'
#' @rdname AssayData
#' @export GetAssay
#'
#' @order 2
#'
#'
GetAssay <- function(object, slot, new.data, ...) {
	UseMethod(generic = 'GetAssay', object = object)
}## end func



#' @describeIn TDEseq-methods Number of cells and features for the active assay
#'
#' @return \code{dim}: The number of features (\code{nrow}) and cells
#' (\code{ncol}) for the default assay; \strong{note}: while the number of
#' features changes depending on the active assay, the number of cells remains
#' the same across all assays
#'
#' @export
#' @method dim TDEseq
#'
#' @examples
#' # Get the number of features in an object
#' nrow(pbmc_small)
#'
#' # Get the number of cells in an object
#' ncol(pbmc_small)
#'
dim.TDEseq <- function(x, assay = NULL) {
  assay <- assay %||% DefaultAssay(object = x)
	return(dim(slot(object = x[[assay]], name = "counts")))
}## end func

#' @describeIn Assay-methods Number of cells and features for the active assay
#'
#' @return \code{dim}: The number of features (\code{nrow}) and cells
#' (\code{ncol}) for the current assay;
#'
#' @export
#' @method dim Assay
#'
#' @examples
#' # Get the number of features in an object
#' nrow(object)
#'
#' # Get the number of cells in an object
#' ncol(object)
#'
dim.Assay <- function(x) {
  return(dim(slot(object = x, name = "counts")))
}## end func


#' @describeIn TDEseq-methods The cell and feature names for the active assay
#'
#' @return \code{dimnames}: The feature (row) and cell (column) names;
#' \strong{note}: while the features change depending on the active assay, the
#' cell names remain the same across all assays
#'
#' @export
#' @method dimnames TDEseq
#'
#' @examples
#' # Get the feature names of an object
#' rownames(pbmc_small)
#'
#' # Get the cell names of an object
#' colnames(pbmc_small)
#'
dimnames.TDEseq <- function(x, assay = NULL) {
  assay <- assay %||% DefaultAssay(object = x)
	return(dimnames(slot(object = x[[assay]], name = "counts")))
}## end func


#' @describeIn Assay-methods The cell and feature names for the active assay
#'
#' @return \code{dimnames}: The feature (row) and cell (column) names;
#' \strong{note}: while the features change depending on the active assay, the
#' cell names remain the same across all assays
#'
#' @export
#' @method dimnames Assay
#'
#' @examples
#' # Get the feature names of an object
#' rownames(object[["RNA"]])
#'
dimnames.Assay <- function(x) {
  return(dimnames(slot(object = x, name = "counts")))
}## end func



#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Internal
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#' @describeIn TDEseq-methods create a TDEseq object using counts, and metadata
#'
#' @param drop See \code{\link[base]{drop}}
#'
#' @return \code{[[}: If \code{i} is missing, the metadata data frame; if
#' \code{i} is a vector of metadata names, a data frame with the requested
#' metadata, otherwise, the requested associated object
#'
#' @export
CreateObject.Each <- function(counts,
                              data = NULL,
                             meta.data = NULL,
                             names.field = 1,
                             names.delim = "_",
                             min.cells = 0,
                             pct.cells = 0.005,
                             min.umi = 10,
                             num.core = 1,
                             min.features = 0,
                             row.names = NULL){
  ## set idents
  idents <- factor(x = unlist(x = lapply(X = colnames(x = counts), 
                                         FUN = ExtractField, 
                                         field = names.field, 
                                         delim = names.delim)))
  

  ## create assay data
  assay.data <- CreateAssayObject(counts = counts,
                                  data = data,
                                  min.cells = min.cells,
                                  pct.cells = pct.cells,
                                  min.umi = min.umi,
                                  min.features = min.features, 
                                  row.names = row.names, 
                                  num.core = num.core)
  assay.data@ident <- idents
  
  ## Create assay data
  
  if(!is.null(meta.data)){
    assay.data <- AddMetaData(assay.data, meta.data = meta.data)
  }## end fi
  
  return(assay.data)
}## end func



#' @param x An object
#' @param n Number of rows to return
#' @inheritDotParams utils::head
#'
#' @return The first or last \code{n} rows of object meta.data
#'
#' @keywords internal
#'
#' @noRd
#'
.head <- function(x, n = 10L, ...) {
	return(head(x = x[[]], n = n, ...))
}## end funcs

#' @describeIn TDEseq-methods Get the first rows of cell-level metadata
#'
#' @return \code{head}: The first \code{n} rows of cell-level metadata
#'
#' @importFrom utils head
#'
#' @export
#' @method head TDEseq
#'
#' @examples
#' # Get the first 10 rows of cell-level metadata
#' head(pbmc_small)
#'
head.TDEseq <- .head


.tail <- function(x, n = 10L, ...) {
	return(tail(x = x[[]], n = n, ...))
}## end funcs
tail.TDEseq <- .tail

#' @describeIn TDEseq-methods Metadata and associated object accessor
#'
#' @param drop See \code{\link[base]{drop}}
#'
#' @return \code{[[}: If \code{i} is missing, the metadata data frame; if
#' \code{i} is a vector of metadata names, a data frame with the requested
#' metadata, otherwise, the requested associated object
#'
#' @export
#' @method [[ TDEseq
#'
#'
"[[.TDEseq" <- function(x, i, ..., drop = FALSE) {
	
	if (missing(x = i)) {
		i <- colnames(x = slot(object = x@assays[[x@active.assay]], name = 'meta.data'))
	}## end fi
	
  if (length(x = i) == 0) {
		return(data.frame(row.names = colnames(x = x)))
	} else if (length(x = i) > 1 || any(i %in% colnames(x = slot(object = x@assays[[x@active.assay]], name = 'meta.data')))) {
		if (any(!i %in% colnames(x = slot(object = x@assays[[x@active.assay]], name = 'meta.data')))) {
		  warning("Cannot find the following bits of meta data: ",	paste0(i[!i %in% colnames(x = slot(object = x, name = 'meta.data'))],
			  collapse = ', ')
		  )
		}## end fi
		i <- i[i %in% colnames(x = slot(object = x@assays[[x@active.assay]], name = 'meta.data'))]
		data.return <- slot(object = x@assays[[x@active.assay]], name = 'meta.data')[, i, drop = FALSE, ...]
		if (drop) {
			data.return <- unlist(x = data.return, use.names = FALSE)
			names(x = data.return) <- rep.int(x = colnames(x = x), times = length(x = i))
		}## end fi
	} else if (length(x = i) > 1 || any(i %in% names(x = x@assays))) {
		## here are two possible name to extract the values
		## extract the assay
		data.return <- x@assays[[i]]
		
	} else {	
	
		slot.use <- ifelse(i %in% slotNames(x = x@assays[[x@active.assay]]), i, NULL)
	  
		if (is.null(x = slot.use)) {
			stop("Cannot find '", i, "' in this TDEseq object", call. = FALSE)
		}## end fi
		data.return <- slot(object = x@assays[[x@active.assay]], name = slot.use)
	}## end fi
	return(data.return)
}## end funcs


#' @describeIn Assay-methods Get expression data from an \code{Assay}
#'
#' @return \code{[}: The \code{data} slot for features \code{i} and cells
#' \code{j}
#'
#' @export
#' @method [ Assay
#'
#'
"[.Assay" <- function(x, i, j, ...) {
  if (missing(x = i)) {
    i <- seq_len(length.out = nrow(x = x))
  }## end fi
  
  if (missing(x = j)) {
    j <- seq_len(length.out = ncol(x = x))
  }# end fi
  
  return(GetTDEseqAssayData(object = x)[i, j, ..., drop = FALSE])
}## end funcs


#' @describeIn Assay-methods Get feature-level metadata
#'
#' @param drop See \code{\link[base]{drop}}
#'
#' @return \code{[[}: The feature-level metadata for \code{i}
#'
#' @export
#' @method [[ Assay
#'
"[[.Assay" <- function(x, i, ..., drop = FALSE) {
  if (missing(x = i)) {
    i <- colnames(x = slot(object = x, name = 'meta.features'))
  }
  data.return <- slot(object = x, name = 'meta.features')[, i, drop = FALSE, ...]
  if (drop) {
    data.return <- unlist(x = data.return, use.names = FALSE)
    names(x = data.return) <- rep.int(x = rownames(x = x), times = length(x = i))
  }
  return(data.return)
}## end func


#' Set a default value depending on if an object is \code{NULL}
#'
#' @param x An object to test
#' @param y A default value
#'
#' @return For \code{\%||\%}: \code{y} if \code{x} is \code{NULL} otherwise
#' \code{x}
#'
#' @importFrom rlang %||%
#'
#' @name set-if-null
#' @rdname set-if-null
#'
#' @export
#'
#' @concept utils
#'
#' @examples
#' 1 %||% 2
#' NULL %||% 2
#'
rlang::`%||%`

#' @rdname set-if-null
#'
#' @return For \code{\%iff\%}: \code{y} if \code{x} is \strong{not}
#' \code{NULL}; otherwise \code{x}
#'
#' @importFrom rlang is_null
#'
#' @export
#'
#' @examples
#' 1 %iff% 2
#' NULL %iff% 2
#'
`%iff%` <- function(x, y) {
  if (!is_null(x = x)) {
    return(y)
  }
  return(x)
}